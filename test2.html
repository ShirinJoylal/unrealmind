<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Superposition — Concepts, Examples & Interactive Demos</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  /* --- Pulsing glow for Bloch card --- */
@keyframes pulseCardGlow {
  0%, 100% {
    box-shadow: 0 6px 20px rgba(125, 211, 252, 0.3);
    filter: brightness(1);
  }
  50% {
    box-shadow: 0 8px 28px rgba(125, 211, 252, 0.5);
    filter: brightness(1.05);
  }
}

#blochCard {
  cursor: pointer;
  transition: transform 0.4s ease, box-shadow 0.4s ease, filter 0.4s ease;
  animation: pulseCardGlow 3s infinite ease-in-out;
}

#blochCard:hover {
  transform: translateY(-4px) scale(1.02);
  box-shadow: 0 0 35px rgba(125,211,252,0.6);
  filter: brightness(1.12);
}

#blochCard:active {
  transform: scale(0.98);
  box-shadow: 0 0 25px rgba(125,211,252,0.7);
}

/* --- Make entire Bloch sphere card clickable & glowing --- */
#blochCard {
  cursor: pointer;
  transition: transform 0.4s ease, box-shadow 0.4s ease, filter 0.4s ease;
  box-shadow: 0 6px 20px rgba(2,6,23,0.4);
}
#blochCard:hover {
  transform: translateY(-4px) scale(1.02);
  box-shadow: 0 0 25px rgba(125,211,252,0.5);
  filter: brightness(1.1);
}
#blochCard:active {
  transform: scale(0.98);
  box-shadow: 0 0 20px rgba(125,211,252,0.6);
}

  :root{--bg1:#0e0547;--bg2:#1b276c;--card:#0f1724;--accent:#7dd3fc;--glass:rgba(255,255,255,0.03);} 
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef8;background:linear-gradient(180deg,var(--bg1),var(--bg2));}
  .wrap{max-width:1100px;margin:28px auto;padding:20px;display:grid;grid-template-columns:1fr 360px;gap:20px;}
  header{grid-column:1/-1;display:flex;align-items:center;gap:16px}
  h1{margin:0;font-size:20px}
  p.lead{opacity:0.9;margin:4px 0 0;font-size:13px}
  .card{background:var(--glass);padding:16px;border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6);}
  .main{display:flex;flex-direction:column;gap:12px}
  .sidebar{display:flex;flex-direction:column;gap:12px}
  .section h2{margin:0 0 6px;font-size:16px}
  .muted{color:#9fb6cf;font-size:13px}
  .demo{height:300px;border-radius:8px;overflow:hidden;position:relative;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  input[type=range]{width:100%}
  label{display:block;font-size:13px;color:#cfe7ff}
  .row{display:flex;gap:8px;align-items:center}
  .imgGrid{display:flex;gap:8px;flex-wrap:wrap}
  .imgCard{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:8px;border-radius:8px;width:120px;text-align:center}
  .imgCard svg{width:100%;height:80px}
  .note{font-size:12px;color:#9fb6cf}
  .double-slit{display:flex;gap:12px;align-items:center}
  .slit{width:6px;height:80px;background:#0b1220;border-radius:2px}
  .screen{width:140px;height:120px;background:linear-gradient(90deg,#071028,#0b1840);border-radius:6px;position:relative}
  .pattern{position:absolute;left:8px;right:8px;top:8px;bottom:8px;display:flex;align-items:center;justify-content:center}
  .fringe{height:100%;width:3px;background:linear-gradient(#7dd3fc55,#7dd3fc11);margin:0 2px;opacity:0.12;}
  .mini-bloch svg{display:block}
  @media (max-width:980px){.wrap{grid-template-columns:1fr;}.sidebar{order:2}}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="card" style="display:flex;align-items:center;gap:12px;padding:10px 14px;">
        <svg width="48" height="48" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="30" stroke="#7dd3fc" stroke-opacity="0.18" stroke-width="2"/><path d="M10 42c8-10 18-12 26-6" stroke="#7dd3fc" stroke-width="2" stroke-linecap="round"/></svg>
        <div>
          <h1>Quantum Superposition — Visual Guide & Demos</h1>
          <p class="lead">Clear explanations, practical examples and small interactive animations that show how superposition produces interference, probabilities and qubits.</p>
        </div>
      </div>
    </header>

    <main class="main card">
      <!-- content omitted here (unchanged from your version) for brevity -->
      <section class="section">
        <h2>Interactive demo — Add two waves</h2>
        <div class="demo" id="demo">
          <canvas id="waveCanvas" style="width:100%;height:100%"></canvas>
        </div>
        <div class="controls">
          <div style="flex:1">
            <label>Left amplitude: <span id="a1Label">0.7</span></label>
            <input id="a1" type="range" min="0" max="1" step="0.01" value="0.7">
          </div>
          <div style="flex:1">
            <label>Right amplitude: <span id="a2Label">0.7</span></label>
            <input id="a2" type="range" min="0" max="1" step="0.01" value="0.7">
          </div>
          <div style="width:160px">
            <label>Phase diff (rad): <span id="phiLabel">0.00</span></label>
            <input id="phi" type="range" min="0" max="6.283" step="0.01" value="0">
          </div>
        </div>
        <p class="note">Move sliders: watch how two wave components sum and the probability density (|ψ|²) changes. Phase controls interference (constructive/destructive).</p>
      </section>

      <!-- other sections unchanged... -->
    </main>

    <aside class="sidebar">
      <div class="card">
        <h3 style="margin-top:0">Quick facts</h3>
        <ul class="muted">
          <li><strong>Wavefunction:</strong> ψ(x) complex; |ψ|² probability.</li>
          <li><strong>Interference:</strong> amplitudes add; intensity depends on the square.</li>
          <li><strong>Collapse:</strong> measurement yields one outcome.</li>
          <li><strong>Coherence:</strong> needed for interference — decoherence destroys superpositions.</li>
        </ul>
      </div>

      <div class="card" id="blochCard">
        <h3 style="margin-top:0">Mini animation — Bloch spin</h3>
        <div style="height:120px;display:flex;align-items:center;justify-content:center" class="mini-bloch">
          <!-- NOTE: single Bloch SVG (id used below) -->
          <svg id="blochSphere" viewBox="0 0 120 120" width="120" height="120" style="cursor:pointer">
            <defs>
              <linearGradient id="g" x1="0" x2="1">
                <stop offset="0" stop-color="#7dd3fc" stop-opacity="0.8"/>
                <stop offset="1" stop-color="#60a5fa" stop-opacity="0.6"/>
              </linearGradient>
            </defs>
            <circle cx="60" cy="60" r="44" fill="#071028" stroke="#7dd3fc" stroke-opacity="0.08"/>
            <g id="blochArrow">
              <line x1="60" y1="60" x2="60" y2="20" stroke="url(#g)" stroke-width="3" stroke-linecap="round"/>
              <polygon points="60,12 56,22 64,22" fill="#7dd3fc" opacity="0.95"/>
            </g>
          </svg>
        </div>
        <div class="muted">Spin states are superpositions of up/down; rotating the Bloch vector changes the amplitudes and phases.</div>
      </div>

      <div class="card">
        <h3 style="margin-top:0">Learn more</h3>
        <div class="muted">If you'd like I can:</div>
        <ul class="muted">
          <li>Add an accurate wavepacket time solver (Crank–Nicolson)</li>
          <li>Include downloadable slides or printable notes</li>
          <li>Create step-by-step classroom exercises</li>
        </ul>
      </div>
    </aside>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // --- Canvas wave demo (same as your working code) ---
  const canvas = document.getElementById('waveCanvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width  = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  const a1 = document.getElementById('a1'), a2 = document.getElementById('a2'), phi = document.getElementById('phi');
  const a1Label = document.getElementById('a1Label'), a2Label = document.getElementById('a2Label'), phiLabel = document.getElementById('phiLabel');
  a1.addEventListener('input', ()=>{ a1Label.textContent = a1.value; draw(); });
  a2.addEventListener('input', ()=>{ a2Label.textContent = a2.value; draw(); });
  phi.addEventListener('input', ()=>{ phiLabel.textContent = Number(phi.value).toFixed(2); draw(); });
const blochCard = document.getElementById('blochCard');
if (blochCard) {
  blochCard.addEventListener('click', () => {
    window.location.assign('test3.html');
  });
}

  function draw(){
    const W = canvas.clientWidth, H = canvas.clientHeight;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,W,H);
    const midY = H*0.5;
    const n = 600;
    const A1 = Number(a1.value), A2 = Number(a2.value), PH = Number(phi.value);
    const freq = 2.2;
    const density = new Array(n);
    for(let i=0;i<n;i++){
      const x = i/(n-1);
      const w1 = A1 * Math.sin(2*Math.PI*freq*x);
      const w2 = A2 * Math.sin(2*Math.PI*freq*x + PH);
      const sum = w1 + w2;
      density[i] = sum*sum;
    }
    let maxD = Math.max(...density); if(maxD===0) maxD = 1;

    ctx.beginPath();
    for(let i=0;i<n;i++){
      const x=i/(n-1), xpos=x*W;
      const ypos = midY - (density[i]/maxD)*(H*0.38);
      if(i===0) ctx.moveTo(xpos,ypos); else ctx.lineTo(xpos,ypos);
    }
    ctx.lineTo(W, H); ctx.lineTo(0,H); ctx.closePath();
    const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'rgba(125,211,252,0.28)'); g.addColorStop(1,'rgba(125,211,252,0.04)');
    ctx.fillStyle = g; ctx.fill();

    // first wave
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.strokeStyle = 'rgba(125,211,252,0.9)';
    for(let i=0;i<n;i++){ const x=i/(n-1), xpos=x*W, y = midY - A1*Math.sin(2*Math.PI*freq*x)*(H*0.18); if(i===0) ctx.moveTo(xpos,y); else ctx.lineTo(xpos,y); } ctx.stroke();

    // second wave
    ctx.beginPath(); ctx.setLineDash([6,4]); ctx.strokeStyle = 'rgba(96,165,250,0.9)';
    for(let i=0;i<n;i++){ const x=i/(n-1), xpos=x*W, y = midY - A2*Math.sin(2*Math.PI*freq*x + PH)*(H*0.18); if(i===0) ctx.moveTo(xpos,y); else ctx.lineTo(xpos,y); } ctx.stroke(); ctx.setLineDash([]);

    // resultant amplitude
    ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.85)'; ctx.lineWidth=1.5;
    for(let i=0;i<n;i++){ const x=i/(n-1), xpos=x*W, y = midY - Math.sqrt(density[i]/maxD)*(H*0.22); if(i===0) ctx.moveTo(xpos,y); else ctx.lineTo(xpos,y); } ctx.stroke();
  }
  draw();

  // --- double-slit pattern render ---
  const pattern = document.getElementById('pattern');
  if (pattern) {
    function renderFringes(){ pattern.innerHTML = '';
      const count = 24; for(let i=0;i<count;i++){ const el = document.createElement('div'); el.className='fringe'; el.style.opacity = (0.06 + 0.12*Math.cos(i*0.4)); pattern.appendChild(el); }
    }
    renderFringes();
  }

  // --- Bloch sphere animation & events ---
  const blochSphere = document.getElementById('blochSphere');
  const blochArrow  = document.getElementById('blochArrow'); // child <g> that we rotate
  if (blochSphere && blochArrow) {
    let angle = 0, direction = 1;

    function animateBloch(){
      angle += direction * 0.8;
      if (angle > 45 || angle < -45) direction *= -1;
      // rotate around SVG center (60,60) because viewBox is 0 0 120 120
      blochArrow.setAttribute('transform', `rotate(${angle} 60 60)`);
      requestAnimationFrame(animateBloch);
    }
    // start animation
    requestAnimationFrame(animateBloch);

    // redirect on click — ensure test3.html exists in same folder
    blochSphere.addEventListener('click', () => {
      // use assign so navigation works reliably
      window.location.assign('test3.html');
    });

    // hover color change (stores original stroke so we can restore)
    const lineEl = blochArrow.querySelector('line');
    const polyEl = blochArrow.querySelector('polygon');
    const origLineStroke = lineEl ? lineEl.getAttribute('stroke') : null;
    const origPolyFill = polyEl ? polyEl.getAttribute('fill') : null;

    blochSphere.addEventListener('mouseenter', () => {
      if (lineEl) lineEl.setAttribute('stroke', '#f87171'); // softer red
      if (polyEl) polyEl.setAttribute('fill', '#f87171');
    });
    blochSphere.addEventListener('mouseleave', () => {
      if (lineEl && origLineStroke) lineEl.setAttribute('stroke', origLineStroke);
      if (polyEl && origPolyFill) polyEl.setAttribute('fill', origPolyFill);
    });
  } else {
    // helpful debug log (remove if undesired)
    // console.warn('Bloch elements not found:', !!blochSphere, !!blochArrow);
  }
});
</script>
</body>
</html>
